/*
 * Copyright (c) 2016, Linaro Limited
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* Driver for the RSA cryptographic module of HiSilicon P660/Hi16xx */

#include <arm.h>
#include <initcall.h>
#include <io.h>
#include <kernel/mutex.h>
#include <mm/core_memprot.h>
#include <mm/core_mmu.h>
#include <platform_config.h>
#include <rng_support.h>
#include <trace.h>
#include <types_ext.h>
#include <util.h>

/* ALG sub-controller registers */

#define ALG_SC_RSA_RESET_DREQ	0x0A9C	/* [0] srst_dreq_rsa */
#define ALG_SC_RSA_CLK_EN	0x03A0	/* [0] clk_rsa_enb */
#define ALG_SC_RSA_CLK_DIS	0x03A4	/* [0] clk_rsa_dsb */
#define ALG_SC_RSA_ADDR_H	0x2E00
#define ALG_SC_DBG_AUTH_CTRL	0x6700	/* [1] rsa_secure_cfg */
					/* [0] rsa_djtag_sec_acc_en */

/*
 * RSA registers
 *
 * Note on physical address format:
 * *_ADDR registers hold the lower 32-bit of a physical address
 * *_VMID registers (except RSA_SAFE_WINDOW_VMID) contain the upper 4 bits of
 * the 36-bit physical address (in bits [7:4]) as well as the VMID (bits [3:0])
 * The value of bits [7:0] of register RSA_HIGH_ADDR_CFG are used to obtain
 * a 44-bit physical address.
 */

#define RSA_CTRL1_OTASK			0x0000
#define RSA_CFG_OTASK			0x0008
#define RSA_CFG_ITASK			0x000C
#  define ITASK_EN			0x1
#  define ITASK_DIS			0x0

#define RSA_CFG_END			0x0010
#  define RSA_CFG_RW_BIG_ENDIAN		0x3
#  define RSA_CFG_RW_LITTLE_ENDIAN	0x0

#define RSA_CFG_PREDIV_ADDR		0x0014
#define RSA_CFG_PREDIV_ADDR_VMID	0x0018
#define RSA_CFG_M_ADDR			0x001C
#define RSA_CFG_M_ADDR_VMID		0x0020
#define RSA_CFG_E_ADDR			0x0024
#define RSA_CFG_E_ADDR_VMID		0x0028
#define RSA_CFG_N_ADDR			0x002C
#define RSA_CFG_N_ADDR_VMID		0x0030

#define RSA_CFG1_KM_ADDR		0x0034
#define RSA_CFG1_KM_ADDR_VMID		0x0038
#define RSA_CFG2_KM_ADDR		0x003C
#define RSA_CFG2_KM_ADDR_VMID		0x0040
#define RSA_CFG3_KM_ADDR		0x0044
#define RSA_CFG3_KM_ADDR_VMID		0x0048
#define RSA_CFG4_KM_ADDR		0x004C
#define RSA_CFG4_KM_ADDR_VMID		0x0050
#define RSA_CFG5_KM_ADDR		0x0054
#define RSA_CFG5_KM_ADDR_VMID		0x0058
#define RSA_CFG6_KM_ADDR		0x005C
#define RSA_CFG6_KM_ADDR_VMID		0x0060
#define RSA_CFG7_KM_ADDR		0x0064
#define RSA_CFG7_KM_ADDR_VMID		0x0068
#define RSA_CFG8_KM_ADDR		0x006C
#define RSA_CFG8_KM_ADDR_VMID		0x0070
#define RSA_CFG9_KM_ADDR		0x0074
#define RSA_CFG9_KM_ADDR_VMID		0x0078
#define RSA_CFG10_KM_ADDR		0x007C
#define RSA_CFG10_KM_ADDR_VMID		0x0080
#define RSA_CFG11_KM_ADDR		0x0084
#define RSA_CFG11_KM_ADDR_VMID		0x0088
#define RSA_CFG12_KM_ADDR		0x008c
#define RSA_CFG12_KM_ADDR_VMID		0x0090

#define RSA_CFG_RESULT_ADDR		0x009C
#define RSA_CFG_RESULT_ADDR_VMID		0x00A0
#define RSA_CFG_PRBS_SEED		0x00A4
#define RSA_INTMSK			0x00A8
#  define ECC_1BIT_ERR			BIT(11)	/* 1-bit errors found in ECC */
#  define ECC_2BIT_ERR			BIT(10)	/* 2-bit errors found in ECC */
#  define AHBM_TIMEOUT			BIT(9)	/* Bus transfer timeout      */
#  define SHB_ERR			BIT(8)	/* Smart heartbeat ecxeption */
#  define AHBM_ERR			BIT(7)	/* Bus transfer error        */
#  define KG4096_FAIL			BIT(6)	/* 4096-bit key gen failure  */
						/* Cause: lack of 2048-bit   */
						/* inner key material        */
#  define KG2048_FAIL			BIT(5)	/* 2048-bit key gen failure  */
						/* Cause: lack of 1024-bit   */
						/* inner key material        */
#  define KG1024_FAIL			BIT(4)	/* 1024-bit key gen failure  */
						/* Cause: lack of 512-bit    */
						/* inner key material        */
#  define DH2_DONE			BIT(3)	/* DH_2ND operation complete */
#  define DH1_DONE			BIT(2)	/* DH_1ST operation complete */
#  define NC_DONE			BIT(1)	/* Mod exp/mult op complete  */
#  define KG_DONE			BIT(0)	/* Key generation complete   */
#  define INTMSK_ALL			0xFFF
#define RSA_RINT			0x00AC	/* W1C ; NC bit 1 */
#define RSA_INTSTS			0x00B0	/* RO ; NC bit 1 */
#define RSA_SHB				0x00B4
#define RSA_CURR_BUSY			0x00B8
#define RSA_CURR_ERROR			0x00BC
#define RSA_CURR_TASK			0x00C0
#define RSA_CURR_KM_CNT			0x00C4
#define RSA_CURR_KM_INI			0x00C8
#define RSA_HIS_LBTASK			0x00CC
#define RSA_NC_DAT_CFG_ERR		0x00F8
#define RSA_NC_DAT_CFG_ERR_CNT		0x00FC

#define RSA_DFX_NC_ST			0x0200	/* [9:8] dfx_nc_w_st	  */
						/* [7:4] dfx_nc_r_st      */
						/* [3:0] dfx_nc_flow_st   */
#define RSA_DFX_KM_ST			0x022C	/* [26:23] dfx_km_w_st    */
						/* [22:15] dfx_mrt_st     */
						/* [14:9]  dfx_gcd_st     */
						/* [8:0]   dfx_km_flow_st */
#define RSA_NC_GET_CNT			0x0300
#define RSA_NC_SUCCESS_CNT		0x0304
#define RSA_NC_STOP_CNT			0x0308
#define RSA_NC_CFG_ERR_CNT		0x030C
#define RSA_OTASK_CFG_CNT		0x0330
#define RSA_CNT_CLR_CE			0x0400	/* [1] snap_en               */
						/* [0] cnt_clr_ce            */
						/*     Read clears stats?    */
#define RSA_ECC_BYPASS			0x0410
#define RSA_SAFE_WINDOW_VMID		0x0500	/* [11:8] safe_win_addr_l_h4 */
						/* [ 7:4] safe_win_addr_h_h4 */
						/* [ 3:0] safe_win_vmid      */
#define RSA_SAFE_WINDOW_ADDR_H		0x0504
#define RSA_SAFE_WINDOW_ADDR_L		0x0508
#define RSA_NC_ADDR_CHECK_FAIL_CNT	0x050C
#define RSA_NC_WINDOW_FAIL_CNT		0x0510
#define RSA_HIGH_ADDR_CFG		0x0F20
#define RSA_USER_ID_CFG			0x0F24

register_phys_mem(MEM_AREA_IO_SEC, ALG_SC_BASE, ALG_SC_REG_SIZE);
register_phys_mem(MEM_AREA_IO_SEC, RSA_BASE, RSA_REG_SIZE);

static vaddr_t rsa;
static vaddr_t alg;

static void __maybe_unused cntpct_wait(int ms)
{
	uint64_t t0, t1;
	uint64_t freq = read_cntfrq();

	t0 = read_cntpct();
	do {
		t1 = read_cntpct();
	} while ((t1 - t0) < (ms * freq / 1000));
}


static uint32_t rsa_read32(int offset)
{
	assert(rsa);
	return read32(rsa + offset);
}

static void rsa_write32(uint32_t val, int offset)
{
	assert(rsa);
	write32(val, rsa + offset);
}

static uint32_t alg_read32(int offset)
{
	assert(alg);
	return read32(alg + offset);
}

static void alg_write32(uint32_t val, int offset)
{
	assert(alg);
	write32(val, alg + offset);
}

#define DUMP_REG(reg) IMSG(#reg "=0x%08x", rsa_read32(reg))

static void __maybe_unused dbg_show_status(void)
{
	DUMP_REG(RSA_CURR_BUSY);
	DUMP_REG(RSA_CURR_TASK);
	DUMP_REG(RSA_CFG_ITASK);
	DUMP_REG(RSA_HIS_LBTASK);
	DUMP_REG(RSA_CURR_BUSY);
	DUMP_REG(RSA_RINT);
	DUMP_REG(RSA_INTSTS);
	DUMP_REG(RSA_SHB);
	DUMP_REG(RSA_CURR_ERROR);
	DUMP_REG(RSA_CFG_M_ADDR);
	DUMP_REG(RSA_CFG_E_ADDR);
	DUMP_REG(RSA_CFG_N_ADDR);
	DUMP_REG(RSA_CFG_RESULT_ADDR);
	DUMP_REG(RSA_NC_GET_CNT);
	DUMP_REG(RSA_NC_SUCCESS_CNT);
	DUMP_REG(RSA_NC_STOP_CNT);
	DUMP_REG(RSA_NC_CFG_ERR_CNT);
	DUMP_REG(RSA_NC_DAT_CFG_ERR);
	DUMP_REG(RSA_NC_DAT_CFG_ERR_CNT);
	DUMP_REG(RSA_NC_SUCCESS_CNT);
	DUMP_REG(RSA_NC_WINDOW_FAIL_CNT);
	DUMP_REG(RSA_NC_ADDR_CHECK_FAIL_CNT);
	DUMP_REG(RSA_OTASK_CFG_CNT);
	DUMP_REG(RSA_DFX_NC_ST);
}

/*
 * Wait for a register to have a specific value with a timeout.
 * Return values: -1: timeout, 0: value is as expected
 */
static int wait_for_value(vaddr_t addr, uint32_t expected, int timeout)
{
	int count = timeout / 10;
	uint32_t val;

	for (;;) {
		val = read32(addr);
		if (val == expected)
			return 0;
		count--;
		if (count < 0)
			return -1;
		cntpct_wait(10);
	}
}

/* Return the number of key materials available for the specified size */
static int get_km_cnt(size_t size)
{
	uint32_t km_cnt;

	km_cnt = rsa_read32(RSA_CURR_KM_CNT);

	switch (size) {
	case 512:
		return km_cnt & 0xF;
	case 1024:
		return (km_cnt >> 4) & 0xF;
	case 2048:
		return (km_cnt >> 8) & 0xF;
	default:
		return -1;
	}
}

/*
 * Wait for key material to be available, max ms milliseconds.
 * Return values: -1: error, 0: timeout, > 0: number of keys
 */
static int __maybe_unused wait_for_km(size_t size, int ms)
{
	int count = ms / 10;
	int s;

	for (;;) {
		s = get_km_cnt(size);
		if (s)
			return s;
		count--;
		if (count < 0)
			return 0;
		cntpct_wait(10);
	}
}

/*
 * Wait for the RSA module to be idle, max ms milliseconds.
 * Return values: -1: timeout, 0: RSA module is idle
 */
static int __maybe_unused wait_for_idle(int ms)
{
	int s;

	s = wait_for_value(rsa + RSA_CURR_BUSY, 0x0, ms);
	IMSG("RSA module is %s", (s < 0) ? "busy" : "idle");

	return s;
}

static uint8_t a_le[] = {
	0x7c, 0xf5, 0xf2, 0x88, 0xe3, 0xe6, 0x68, 0x5e, 0x23, 0xb8, 0x99, 0x0e, 0x7b, 0x9c, 0x60, 0xf2,
	0xcf, 0x5f, 0x41, 0xc1, 0x71, 0x06, 0x79, 0x5f, 0x8a, 0xf4, 0xb8, 0xd9, 0x2a, 0xce, 0x01, 0xc5,
	0x20, 0x04, 0x00, 0x05, 0x01, 0x02, 0x04, 0x03, 0x65, 0x01, 0x48, 0x86, 0x60, 0x09, 0x06, 0x0d,
	0x30, 0x31, 0x30, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
};

static uint8_t b_le[] = { 0x01, 0x00, 0x01, };

static uint8_t c_le[] = {
	0x35, 0xfc, 0x27, 0xbf, 0x26, 0xdb, 0x75, 0x33, 0x1e, 0x02, 0xd8, 0x92, 0xb0, 0x86, 0xa3, 0x1f,
	0xd0, 0x9a, 0x09, 0xa5, 0xe4, 0x95, 0x3a, 0xd2, 0x37, 0x85, 0xc6, 0xec, 0xe8, 0xf8, 0x27, 0x54,
	0x59, 0x87, 0xbf, 0x27, 0xb0, 0xca, 0xba, 0x13, 0xe3, 0x98, 0x1d, 0x8e, 0x72, 0xf8, 0xa1, 0x71,
	0x3a, 0xba, 0x4d, 0xdd, 0x95, 0xb4, 0x3c, 0x05, 0xf0, 0xf7, 0xaa, 0x1d, 0xbf, 0x5e, 0x04, 0xe0,
	0x1a, 0x99, 0x72, 0x32, 0xb0, 0x77, 0x8e, 0x88, 0x9c, 0xfb, 0x5f, 0x8c, 0xf9, 0x82, 0x2e, 0x98,
	0xf8, 0xa0, 0x70, 0xf9, 0xaa, 0x54, 0x60, 0x7f, 0xc7, 0x17, 0xef, 0x41, 0xb8, 0x9c, 0x50, 0x54,
	0x6e, 0x2d, 0xbe, 0x16, 0xea, 0xa3, 0xca, 0xb0, 0x5e, 0x8b, 0x82, 0x1e, 0xdf, 0xfc, 0x7c, 0x1f,
	0xeb, 0x3d, 0xd7, 0x46, 0x01, 0x76, 0xff, 0x05, 0x2e, 0x25, 0x2e, 0xb6, 0xfa, 0x0b, 0xd0, 0xf8,
	0x86, 0xa1, 0x86, 0xae, 0x51, 0x40, 0xd4, 0x8b, 0xeb, 0x66, 0x48, 0x9b, 0x57, 0x8e, 0x18, 0xbf,
	0x3e, 0xca, 0xee, 0xa0, 0x00, 0x1f, 0x6c, 0x1c, 0xea, 0x71, 0xc8, 0x9f, 0x8b, 0x8b, 0xe8, 0x7f,
	0x5b, 0x8b, 0xbf, 0x9b, 0xa0, 0x84, 0x89, 0xba, 0xf9, 0x16, 0x2f, 0xcd, 0x73, 0x0f, 0x1c, 0x35,
	0x72, 0xd6, 0xb9, 0x77, 0xb0, 0xf4, 0x2c, 0x1c, 0x51, 0x0c, 0xba, 0x5b, 0xf3, 0x01, 0x12, 0xcc,
	0x3a, 0xd2, 0xa5, 0x00, 0x60, 0xfe, 0x5f, 0xf2, 0xa8, 0x69, 0xac, 0x43, 0x19, 0xc6, 0xa5, 0x6e,
	0x0c, 0x52, 0xdf, 0x9d, 0xb4, 0x28, 0xc0, 0x5a, 0x15, 0xea, 0xdd, 0x66, 0xf6, 0x90, 0x2f, 0xf1,
	0xe1, 0xa0, 0xef, 0x9e, 0xe6, 0x91, 0x86, 0xc0, 0x92, 0xe0, 0xb1, 0x0a, 0x42, 0x88, 0x49, 0x5a,
	0xbb, 0xac, 0x9b, 0x40, 0x7d, 0x2b, 0x90, 0x0c, 0xe3, 0xce, 0xb3, 0xc0, 0xad, 0x18, 0x5a, 0xa6,
};

static uint8_t d_le[] __maybe_unused = {
	0x7c, 0xf5, 0xf2, 0x88, 0xe3, 0xe6, 0x68, 0x5e, 0x23, 0xb8, 0x99, 0x0e, 0x7b, 0x9c, 0x60, 0xf2,
	0xcf, 0x5f, 0x41, 0xc1, 0x71, 0x06, 0x79, 0x5f, 0x8a, 0xf4, 0xb8, 0xd9, 0x2a, 0xce, 0x01, 0xc5,
	0x20, 0x04, 0x00, 0x05, 0x01, 0x02, 0x04, 0x03, 0x65, 0x01, 0x48, 0x86, 0x60, 0x09, 0x06, 0x0d,
	0x30, 0x31, 0x30, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
};

static struct win {
	uint8_t a[256], b[256], c[256], d[256];
	uint32_t end __aligned(4);
} win;

#define a win.a
#define b win.b
#define c win.c
#define d win.d

/*
 * Enable the RSA module and start generating key material
 */
static TEE_Result hi16xx_rsa_init(void)
{
	uint32_t val;

	alg = (vaddr_t)phys_to_virt(ALG_SC_BASE, MEM_AREA_IO_SEC);
	rsa = (vaddr_t)phys_to_virt(RSA_BASE, MEM_AREA_IO_SEC);


	/* De-activate software reset */
	val = alg_read32(ALG_SC_RSA_RESET_DREQ);
	alg_write32(val | BIT(0), ALG_SC_RSA_RESET_DREQ);

	/* Enable clock */
	val = alg_read32(ALG_SC_RSA_CLK_EN);
	alg_write32(val | BIT(0), ALG_SC_RSA_CLK_EN);

	/* Configure non-secure mode, because output mem is non-secure */
	val = alg_read32(ALG_SC_DBG_AUTH_CTRL);
	alg_write32(val & ~BIT(1), ALG_SC_DBG_AUTH_CTRL);

	/* Set big-endian mode */
	rsa_write32(RSA_CFG_RW_BIG_ENDIAN, RSA_CFG_END);

	/* Set query mode */
	rsa_write32(INTMSK_ALL, RSA_INTMSK);

	rsa_write32(virt_to_phys(&a[0]), RSA_SAFE_WINDOW_ADDR_L);
	rsa_write32(virt_to_phys(&win.end), RSA_SAFE_WINDOW_ADDR_H);
	rsa_write32(0, RSA_SAFE_WINDOW_VMID);

	IMSG("Hi16xx RSA initialized");
	return TEE_SUCCESS;
}

static void le2be(uint8_t *to, uint8_t *from, size_t size)
{
	uint8_t *t = to + 255;

	DMSG("from=");
	DHEXDUMP(from, size);
	assert(size <= 256);
	while (size--)
		*(t--) = *(from++);
	DMSG("to=");
	DHEXDUMP(to, 256);
}

static void test_rsa_sign(void)
{
	int s;
	int size = 2048;
	uint32_t val;
	uint8_t *M, *E, *N, *o;

	dbg_show_status();

	/* TODO? Also wait for RSA_CURR_TASK_REG otask == 0 */
	s = wait_for_idle(0);
	if (s < 0)
		return;

	if (rsa_read32(RSA_INTSTS) & 0x1) {
		IMSG("Unexpected: KG task completion interrupt is pending");
		return;
	}

	le2be(a, a_le, sizeof(a_le));
	le2be(b, b_le, sizeof(b_le));
	le2be(c, c_le, sizeof(c_le));
	M = a;
	E = b;
	N = c;
	o = d;

	/*
	 * Configure outer task as Normal CODEC (NC) task for modular
	 * exponentiation
	 *   o = M ^ E (mod N)
	 */
	val = rsa_read32(RSA_CFG_OTASK);
	/* ns (non-secure) means result is *not* in safe window */
	//val |= BIT(22) /* ns */ | BIT(8) /* NC */ | (size/32 - 1);
	val |= BIT(8) /* NC */ | (size/32 - 1);
	rsa_write32(val, RSA_CFG_OTASK);

	/* M */
	rsa_write32(virt_to_phys(M), RSA_CFG_M_ADDR);
	rsa_write32(0, RSA_CFG_M_ADDR_VMID);

	/* E */
	rsa_write32(virt_to_phys(E), RSA_CFG_E_ADDR);
	rsa_write32(0, RSA_CFG_E_ADDR_VMID);

	/* N */
	rsa_write32(virt_to_phys(N), RSA_CFG_N_ADDR);
	rsa_write32(0, RSA_CFG_N_ADDR_VMID);

	/* c */
	rsa_write32(virt_to_phys(o), RSA_CFG_RESULT_ADDR);
	rsa_write32(0, RSA_CFG_RESULT_ADDR_VMID);

	IMSG("Starting NC task");
	rsa_write32(BIT(0), RSA_CTRL1_OTASK);

	IMSG("Waiting for idle");
	s = wait_for_idle(1000);
	if (s < 0)
		IMSG("NC timeout");
	else
		IMSG("NC done");

	DMSG("o=");
	DHEXDUMP(o, size/8);
	dbg_show_status();
}

void hi16xx_rsa_debug(void);
void hi16xx_rsa_debug(void)
{
	/* gen_key_pair(1024); */
	test_rsa_sign();
}

driver_init_late(hi16xx_rsa_init);
